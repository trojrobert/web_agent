import os
from autogen_agentchat.agents import AssistantAgent, UserProxyAgent
from autogen_agentchat.conditions import MaxMessageTermination, TextMentionTermination
from autogen_agentchat.teams import SelectorGroupChat
from autogen_agentchat.ui import Console
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_ext.agents.web_surfer import MultimodalWebSurfer
from dotenv import load_dotenv

load_dotenv() # Load the environment variables



async def run_multi_agent_task(user_task) -> str:
    """
    Runs the multi-agent system to process a user-provided task.

    Args:
        user_task (str): The task to be completed by the agents.

    Returns:
        str: The result or summary generated by the agents.
    """
    # Initialize the LLM client with the desired model
    model_client = OpenAIChatCompletionClient(model="gpt-4o-mini", api_key=os.getenv("OPENAI_API_KEY"))

    # Define termination conditions for the conversation
    # Stops the conversation after either 20 messages or when the keyword "TERMINATE" is mentioned
    termination_condition = MaxMessageTermination(max_messages=20) | TextMentionTermination("TERMINATE")

    # Web Surfer Agent: Responsible for browsing the web and retrieving relevant information
    web_surfer_agent = MultimodalWebSurfer(
        name="web_surfer_agent",
        description="Agent that browses the web and retrieves information to solve tasks.",
        model_client=model_client,
        headless=False,  # Set to True if running in a headless environment
    )

    # Assistant Agent: Verifies and summarizes information retrieved by the Web Surfer Agent
    assistant_agent = AssistantAgent(
        name="assistant_agent",
        description="Agent that validates and summarizes information retrieved by the web surfer agent.",
        system_message=(
            """You are an assistant tasked with verifying and summarizing information retrieved by the web surfer agent.
            - If the web surfer agent's response does not fully address the task, provide clear instructions on what remains 
              to be done and respond with 'keep going'.
            - If the task is fully addressed, provide a detailed summary and final response to the user, then conclude with 'TERMINATE'.
            Be precise and ensure all user requirements are met before summarizing."""
        ),
        model_client=model_client,
    )

    # User Proxy Agent: Acts as a fallback for user input or clarification when required
    user_proxy_agent = UserProxyAgent(
        name="user_proxy_agent",
        description="A human user consulted when agents need clarification, preferences, or additional information.",
    )

    # Selector Prompt: Coordinates the flow of roles during task execution
    # Defines how to decide which agent (web surfer, assistant, or user proxy) should act next
    role_selector_prompt = (
        """You are the coordinator of this multi-agent role-play system. There are three roles available:
        {roles}.

        Task Description:
        - The web_surfer_agent retrieves information from the web.
        - The assistant_agent verifies and summarizes the information provided by the web_surfer_agent.
        - If additional input or clarification is required from the user, the user_proxy_agent will assist.

        Your Role:
        - Based on the task and the ongoing conversation ({history}), decide which agent should act next.
        - Only return the name of the selected role from {participants}.
        """
    )


    # Team Setup: Defines the group of agents and their coordination logic
    multi_agent_team = SelectorGroupChat(
        [web_surfer_agent, assistant_agent, user_proxy_agent],
        selector_prompt=role_selector_prompt,
        model_client=OpenAIChatCompletionClient(model="gpt-4o-mini"),
        termination_condition=termination_condition,
    )

    # Capture results from the async generator
    results = []
    async for message in multi_agent_team.run_stream(task=user_task):

        # Extract the text content from each TextMessage object
        results.append(f"***** /n {str(message)}")  # Convert message.content to a string
    

    # Close all agents
    await web_surfer_agent.close()
    await assistant_agent.close()
    await user_proxy_agent.close()

    # Join results and return
    return "\n".join(results)

